/*
Copyright 2024 Klutch Authors. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
	"fmt"
	"reflect"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/intstr"

	utilerr "github.com/anynines/klutchio/provider-anynines/pkg/utilerr"
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

// Possible states of the Service Instance
// https://github.com/anynines/anynines_service_broker/blob/0f4d0502745f229a8b73414df0239883f3a87704/app/models/anynines/instance.rb
const (
	StateCreated     = "created"
	StateProvisioned = "provisioned"
	StateAvailable   = "available"
	StateDeleted     = "deleted"
	StateDeleting    = "deleting"
	StateDeploying   = "deploying"
	StateFailed      = "failed"
	StateUnknown     = "unknown"

	errNotInitialized        = "service instance not initialized yet - required status field %s is unset"
	errInstanceIDStatusUnset = "InstanceID has not been set"

	// ErrServiceInstanceNotFound is the message of the error that is triggered when service instance referenced
	// is not found.
	ErrServiceInstanceNotFound = utilerr.PlainUserErr("data service instance was not found")
	// errGetServiceInstance is the message of the error that is triggered when one service instance is expected
	// but not found
	errGetServiceInstance = "cannot get one service instance"
)

// OriginatingIdentity requires a client API version >=2.13.
//
// OriginatingIdentity is used to pass to the broker service an identity from
// the platform
type OriginatingIdentity struct {
	// The name of the platform to which the user belongs
	Platform *string `json:"platform,omitempty"`
	// A serialized JSON object that describes the user in a way that makes
	// sense to the platform
	Value *string `json:"value,omitempty"`
}

// ServiceInstanceObservation are the observable fields of a ServiceInstance.
type ServiceInstanceObservation struct {
	State         string `json:"state,omitempty"`
	ProvisionedAt string `json:"provisionedAt,omitempty"`
	DeletedAt     string `json:"deletedAt,omitempty"`
	CreatedAt     string `json:"createdAt,omitempty"`
	UpdatedAt     string `json:"updatedAt,omitempty"`
	// PlanID is the ID of the plan to use for the new instance. The ID is used
	// for communicating with the a9s Service Broker and populated by this provider.
	PlanID string `json:"planId,omitempty"`
	// ServiceID is the ID of the service to provision a new instance of. The ID
	// is used for communicating with the a9s Service Broker and populated by
	// this provider.
	ServiceID string `json:"serviceId,omitempty"`
	// InstanceID is the generated unique ID of the the new instance. The ID is used for
	// communicating with the a9s Service Broker and is generated by this provider.
	InstanceID string `json:"instanceId,omitempty"`
	// Parameters are the user parameters of the currently deployed instance.
	Parameters map[string]intstr.IntOrString `json:"parameters,omitempty"`
}

// A ServiceInstanceSpec defines the desired state of a ServiceInstance.
type ServiceInstanceSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	// From docs: While the rest of the fields relate to how Crossplane should
	// behave, the fields under forProvider are solely used to configure the
	// actual external resource. In most of the cases, the field names correspond
	// to the what exists in providerâ€™s API Reference.
	ForProvider ServiceInstanceParameters `json:"forProvider"`
}

type ServiceInstanceParameters struct {
	// AcceptsIncomplete indicates whether the client can accept asynchronous
	// provisioning. If the broker cannot fulfill a request synchronously and
	// AcceptsIncomplete is set to false, the broker will reject the request.
	// A broker may choose to response to a request with AcceptsIncomplete set
	// to true either synchronously or asynchronously.
	// +kubebuilder:default:=true
	AcceptsIncomplete *bool `json:"acceptsIncomplete"`
	// ServiceName is the human-readable name of the service to provision a new
	// instance of, e.g. a9s-postgresql13. This value must be filled in by the
	// entity creating the ServiceInstance object.
	// +kubebuilder:validation:Required
	ServiceName *string `json:"serviceName"`
	// PlanName is the human-readable name of the plan to use for the new
	// instance, e.g. postgresql-replica-small. This value must be filled in by
	// the entity creating the ServiceInstance object.
	// +kubebuilder:validation:Required
	PlanName *string `json:"planName"`
	// OrganizationGUID is the platform GUID for the organization under which
	// the service is to be provisioned. CF-specific.
	OrganizationGUID *string `json:"organizationGuid"`
	// SpaceGUID is the identifier for the project space within the platform
	// organization. CF-specific.
	SpaceGUID *string `json:"spaceGuid"`
	// Parameters is a set of configuration options for the service instance.
	// Optional.
	Parameters map[string]intstr.IntOrString `json:"parameters,omitempty"`
	// Context requires a client API version >= 2.12.
	//
	// Context is platform-specific contextual information under which the
	// service instance is to be provisioned.
	Context map[string]string `json:"context,omitempty"`
	// OriginatingIdentity requires a client API version >= 2.13.
	//
	// OriginatingIdentity is the identity on the platform of the user making
	// this request.
	OriginatingIdentity *OriginatingIdentity `json:"originatingIdentity,omitempty"`
}

// Available options are:
// CREATEDB - Gives the user permission to create and drop new databases.
// CREATEROLE - Gives the user permission to create, delete, and alter the
// attributes of a role.
// REPLICATION - Gives the role permission to create and drop replication slots
// and connect to the service in replication mode.
// +kubebuilder:validation:Enum:=CREATEDB;CREATEROLE;REPLICATION
// nolint:golint,unused
type rolePrivilegeString string

// A ServiceInstanceStatus represents the observed state of a ServiceInstance.
type ServiceInstanceStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          ServiceInstanceObservation `json:"atProvider,omitempty"`
	PendingOperation    *string                    `json:"pendingOperation,omitempty"`
}

// +kubebuilder:object:root=true

// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,anynines}
type ServiceInstance struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`

	Spec   ServiceInstanceSpec   `json:"spec"`
	Status ServiceInstanceStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServiceInstanceList contains a list of ServiceInstance
type ServiceInstanceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServiceInstance `json:"items"`
}

// Service Instance type metadata.
var (
	ServiceInstanceKind             = reflect.TypeOf(ServiceInstance{}).Name()
	ServiceInstanceGroupKind        = schema.GroupKind{Group: Group, Kind: ServiceInstanceKind}.String()
	ServiceInstanceKindAPIVersion   = ServiceInstanceKind + "." + SchemeGroupVersion.String()
	ServiceInstanceGroupVersionKind = SchemeGroupVersion.WithKind(ServiceInstanceKind)
)

func init() {
	SchemeBuilder.Register(&ServiceInstance{}, &ServiceInstanceList{})
}

func (p *ServiceInstance) GetInstanceID() (string, error) {
	if p.Status.AtProvider.InstanceID == "" {
		return "InstanceID not set", fmt.Errorf(errInstanceIDStatusUnset)
	}
	return p.Status.AtProvider.InstanceID, nil
}

func (p *ServiceInstance) GetPlanID() (string, error) {
	if p.Status.AtProvider.PlanID == "" {
		return "", fmt.Errorf(errNotInitialized, "Status.AtProvider.PlanID")
	}
	return p.Status.AtProvider.PlanID, nil
}

func (p *ServiceInstance) GetServiceID() (string, error) {
	if p.Status.AtProvider.ServiceID == "" {
		return "", fmt.Errorf(errNotInitialized, "Status.AtProvider.ServiceID")
	}
	return p.Status.AtProvider.ServiceID, nil
}

func (list *ServiceInstanceList) ToServiceInstance(name string) (*ServiceInstance, error) {
	var err (error)
	switch {
	case len(list.Items) > 1:
		err = fmt.Errorf(
			"%s, expected 1 ServiceInstance managed resource for %s, but got %d",
			errGetServiceInstance,
			name,
			len(list.Items),
		)
	case len(list.Items) == 0:
		err = fmt.Errorf(
			"%s, failed to list ServiceInstance managed resources for %s: %w",
			errGetServiceInstance,
			name,
			ErrServiceInstanceNotFound,
		)
	default:
		return &list.Items[0], nil
	}

	return nil, err
}
